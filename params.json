{
  "name": "Jump",
  "tagline": "Just Unity Multiplayer with Photon",
  "body": "# JUMP (Just Unity Multiplayer with Photon)\r\n\r\n**JUMP** is a library that facilitates writing **simple multiplayer games** using **[Unity 3D]** \r\nand **[Photon Unity Networking]**.\r\n\r\nI was working on a multiplayer game and found myself in trouble trying to handle events from \r\nUnity and Photon at the same time; ending up with fragile code - so I worked to \r\nstreamline and simplify the scenario and build a reusable library.\r\n\r\nOut of the box, **JUMP** Provides:\r\n- A simple flow for connecting to the server, matchmaking and starting a multiplayer game\r\n- Authoritative local Server (using Photon Master Client)\r\n- Streamlined Client-Server communication\r\n- Custom Client Commands and Server Snapshots\r\n- Sample Project and Prefabs to get started in 5 minutes\r\n- Full source code access and great customization.\r\n\r\n#### Version\r\n0.1 [04/30/2016]\r\n\r\n#### Table of Content\r\n* **[How To Install](#how-to-install)**\r\n* **[Scenario](#scenario)**\r\n* **[Object Model](#object-model)**\r\n* **[DiceRoller Sample](#diceroller-sample)**\r\n* **[Testing JUMP](#testing-jump)**\r\n* **[Features to Add](#features-to-add)**\r\n* **[License](#license)**\r\n\r\n# How to Install\r\nYou can get the source code here or download **JUMP** from the [Unity Asset Store][JUMPAsset].\r\n\r\n#### Prerequisites\r\n**JUMP** works with [Unity 5](https://unity3d.com/5) and requires [Photon PUN](https://www.assetstore.unity3d.com/en/#!/content/1786) to function properly:\r\n\r\n1. Install [Photon PUN Free](https://www.assetstore.unity3d.com/en/#!/content/1786) or [Photon PUN+](https://www.assetstore.unity3d.com/en/#!/content/12080)\r\n2. Configure your Photon Application ID - see [Initial Setup](https://doc.photonengine.com/en/pun/current/getting-started/initial-setup)\r\n\r\nFor more information about configuring PUN, see [PUN Setup](https://doc.photonengine.com/en/pun/current/getting-started/initial-setup).\r\n\r\n> Note: JUMP was tested with Unity version 5.3.4 and Photon PUN Free version 1.67\r\n\r\n#### Option 1: Unity Asset Store\r\nThe [Unity Asset Store][JUMPAsset] package includes the [DiceRoller](#diceroller-sample) sample project.\r\n\r\n* Download **JUMP** from the [Unity Asset Store][JUMPAsset].\r\n* Add all the scenes in the `DiceRollerSample/` to the Unity build\r\n* Open the `DiceRollerConnection` scene and start Unity.\r\n* The DiceRoller sample should go to the Matchmake scene in connected mode.\r\n\r\n> Note: To test multiplayer games in Unity, you will need to run two copies of the game, so that they can connect to each other. The best way, is to build a copy of the game (File/Build & Run) for one player and start Unity debugging for the second player. See this Unity [forum post](http://answers.unity3d.com/questions/214802/how-to-test-your-multiplayer-game.html) for more details.\r\n \r\n#### Option 2: From GitHub source code\r\nIn alternative to use the Asset store, you can create a folder in the unity project (under Assets) and copy all the files from the `JUMP Multiplayer\\` folder.\r\nThen you can use the [Object Model](#object-model) and the prefabs.\r\n\r\n# Scenario\r\nThe scenario supported by JUMP is very simple and designed with mobile multiplayer games in mind:\r\n* [Two Players networking](#two-players-networking)\r\n* [Basic matchmaking](#basic-matchmaking)\r\n* [Streamlined UI flow](#streamlined-ui-flow)\r\n* [Custom server](#custom-server)\r\n* [Client-Server communication](#client-server-communication)\r\n\r\n#### Two Players networking\r\nJUMP automates building [Photon] rooms with two players, easy.\r\n \r\n*Note:* While it can be extended to support more than two players, the support for UI flow is only for the two players scenario\r\n\r\n#### Basic Matchmaking\r\nJUMP supports a single [Photon Lobby] with [Random Matchmaking](https://doc.photonengine.com/en/realtime/current/reference/matchmaking-and-lobby).\r\n\r\n#### Streamlined UI flow\r\nJUMP supports up to five different Unity scenes:\r\n* Connection\r\n* Home Page (Master)\r\n* Matchmaking Lobby\r\n* [Room] Waiting for players\r\n* [Room] Playing the game\r\n\r\n*Note:* support for multiple levels can be added to the Playing the game scene. \r\n\r\n![](https://raw.githubusercontent.com/MaurGi/JUMP/master/Doc/UIFlow.png)\r\n\r\n#### Custom Server\r\nJUMP cannot provide a dedicated remote server using [Photon Unity Networking] or [Photon Cloud], so it uses the **Host** model, where one of the clients also hosts the Game Server (sometimes called **Local Server**) \r\n\r\nPhoton provides support for this with the concept of [Master Client].\r\n\r\n#### Client-Server Communication\r\nJUMP supports the concept of an Authoritative or Semi-Authoritative server using a Command/Snapshot Client-Server communication:\r\n* The Client sends Commands to the Server\r\n* The Server sends Snapshot to the Client\r\n\r\nThe model is similar to the one explained by [Fast Paced Multiplayer] [Gambetta], but we use the term **Command** instead of Actions and **Snapshot** instad of New State\r\n\r\n![](https://raw.githubusercontent.com/MaurGi/JUMP/master/Doc/ClientServer.png)\r\n\r\n> The slanted lines indicate that there is lag between the client and server communication, see [Fighting Latency on Call of Duty III] [CallOfDuty]\r\n\r\n\r\nWhile it is possible to optimize the client/server communication in terms of reliability and space utilized with delta compression of snapshots and queues of commands, JUMP simply uses \r\n[Photon Reliable UDP](https://doc.photonengine.com/en/onpremise/current/getting-started/photon-server-intro) to communicate, it is a good balance of reliability and ease-of-use.\r\n\r\n#### References\r\nJUMP Multiplayer with (Semi)Authoritative Server model is based on lots of literature on multiplayer games:\r\n* [Fast Paced Multiplayer] [Gambetta]  (Gambetta)\r\n* [What every programmer needs to know about game networking](http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/) (Gaffer on Games)\r\n* [Fighting Latency on Call of Duty Black Ops III] [CallOfDuty]  (GDC 2016)\r\n* [Building a Peer-to-Peer Multiplayer Networked Game](http://gamedevelopment.tutsplus.com/tutorials/building-a-peer-to-peer-multiplayer-networked-game--gamedev-10074)\r\n* [Unity3D Multiplayer Game Development](http://www.pepwuper.com/unity3d-multiplayer-game-development-unity-networking-photon-and-ulink-comparison/)\r\n* [How can I make a peer-to-peer multiplayer game?](http://gamedev.stackexchange.com/questions/3887/how-can-i-make-a-peer-to-peer-multiplayer-game/3891#3891)\r\n* [Unity Networking](http://docs.unity3d.com/Manual/UNetConcepts.html)\r\n\r\n# Object Model\r\nJUMP Uses the following classes:\r\n* [`JUMPMultiplayer`](#jumpmultiplayer)\r\n* [`JUMPGameClient`](#jumpgameclient)\r\n* [`JUMPGameServer`](#jumpgameserver)\r\n* [`IJUMPGameServerEngine`](#ijumpgameserverengine)\r\n* [`JUMPCommand`](#jumpcommand)\r\n* [`JUMPCommand_Snapshot`](#jumpcommand_snapshot)\r\n* [`JUMPPlayer`](#jumpplayer)\r\n* [`JUMPOptions`](#jumpoptions)\r\n\r\n#### JUMPMultiplayer\r\n`JUMPMultiplayer` is the main class in **JUMP**, handling the connection to the server, the matchmaking, setting up the game room and managing the game client and server. \r\n`JUMPMultiplayer` inherits from [`Photon.PunBehaviour`](http://doc-api.exitgames.com/en/pun/current/class_photon_1_1_pun_behaviour.html), which in turn extends `UnityEngine.MonoBehaviour` to interact both with Photon Networking and Unity Scenes.\r\n\r\nTo use `JUMPMultiplayer`, you place it on a Unity Scene, set the `Stage` property and handle the UnityEvents that are raised by loading other scenes and setting a different Stage or issuing commands. See [DiceRoller Sample](#diceroller-sample) for an example.\r\n\r\nTo facilitate development, **JUMP** provides a series of **JUMPMultiplayer Prefabs** see details [here](#jumpmultplayer-prefabs) \r\n\r\n##### `JUMPMultiplayer.Stage`\r\n`JUMPMultiplayer` works in stages, one for each of the [Steamlined UI flow](#streamlined-ui-flow)\r\n\r\n```c#\r\npublic enum Stages\r\n{\r\n    Connection,\r\n    Master,\r\n    MatchmakeLobby,\r\n    GameRoom,\r\n    Play\r\n}\r\n```\r\n\r\nAt high level the `Stages` state diagram is the following:\r\n\r\n![](https://raw.githubusercontent.com/MaurGi/JUMP/master/Doc/StateDiagram.png)\r\n\r\nIn more detail, based on the current stage, `JUMPMultiplayer` provides the following events and operations:\r\n##### `Stages.Connection`\r\nIn the `Connection` stage, JUMP will try to connect to Photon Server, using the [Photon connection settings](https://doc-api.photonengine.com/en/pun/current/class_photon_network.html#a0fdb79bcce45801ec81fbe56ffb939ec):\r\n\r\nWhen the connection is established, the `OnMasterConnnect` event is raised:\r\n```c#\r\npublic UnityEvent OnMasterConnect;\r\n```\r\nYou respond to the event by loading a different Unity Scene with a `JUMPMultiplayer` object set in to the `Master` stage.\r\nNote that if the connection fails, then the `OnMasterConnect` event is raised, but the `JUMPMultiplayer.IsOffline` property is set to true.\r\n##### `Stages.Master`\r\nThe `Master` stage is the main screen one, the user is connected to Photon, but not yet into a matchmaking queue or in a game room.\r\nWhile connected to the Photon Master server (but not in a Lobby or Room), the `JUMPMultiplayer.IsConnectedToMaster` property will be set to `true`.\r\n\r\nTo start the matchmaking proces, you call the `Matchmake` operation:\r\n```c#\r\npublic void Matchmake()\r\n```\r\nThis triggers the request to connect to the default [Photon Matchmaking Lobby](https://doc.photonengine.com/en/realtime/current/reference/matchmaking-and-lobby) for your game.\r\n\r\nWhen the connection succees, the `OnMatchmakeLobbyConnect` event is fired. You want to handle this event by loading the Mathcmaking scene.\r\n```c#\r\npublic UnityEvent OnMatchmakeLobbyConnect;\r\n```\r\n\r\nIf the connection fails or we lose connection to the PhotonServer, then the `OnMasterDisconnect` event is fired. You want to handle this event by going back to the 'Connection' scene to try and reconnect once - if reconnection fails, you will be navigate again to the main scree with the `IsOffline` property set to true - in which case, you want to tell your users that they are offline. \r\n```c#\r\npublic UnityEvent OnMasterDisconnect;\r\n```\r\n##### `Stages.MatchmakeLobby`\r\nIn the Matchmake lobby, JUMP will try to matchmake to a [Photon Game Room](https://doc.photonengine.com/en/realtime/current/reference/matchmaking-and-lobby) using Randon matchmaking.\r\nWhile connected to the Photon Lobby, the `JUMPMultiplayer.IsConnectedToMatchmakeLobby` property will be set to `true`.\r\n\r\nYou can cancel the attempt to matchmake by calling the `CancelMatchmake` operation:\r\n```c#\r\npublic void CancelMatchmake()\r\n```\r\nThis will cancel the request to matchmake and raise the `OnMatchmakeLobbyDisconnect` event:\r\n```c#\r\npublic UnityEvent OnMatchmakeLobbyDisconnect;\r\n```\r\nThe `OnMatchmakeLobbyDisconnect` is also triggered in case of loss of connection to Photon.\r\nYou want to handle this event by going back to the Main screen ([`Stages.Master`](#stagesmaster))\r\n\r\nWhen a game room is found then the `OnGameRoomConnect` event is fired:\r\n```c#''\r\npublic UnityEvent OnGameRoomConnect;\r\n```\r\nIf no room is not found, then one is created and the user is joined to it waiting for other players. The same `OnGameRoomConnect` event is fired.\r\nYou want to handle this even by loading a scene that tells the users they are waiting for the other player to connect.\r\n\r\nWhen the client connects to the Game Room, an instance of the [`JUMPGameServer`](#jumpgameserver) is created - this will invoke your custom Server Engine. Just implement the [`IJUMPGameServerEngine`](#ijumpgameserverengine) interface in your class and provide the name of the class (including the namespace) to the `GameServerEngineTypeName` property:\r\n```c#\r\npublic string GameServerEngineTypeName;\r\n```\r\n##### `Stages.GameRoom`\r\nIn this stage, the player is connected to a [Photon Game Room](https://doc.photonengine.com/en/realtime/current/reference/matchmaking-and-lobby) and waiting for the room to be full with two players.\r\nWhile connected to the Game Room, the `JUMPMultiplayer.IsConnectedToGameRoom` property will be set to `true`.\r\n\r\nYou can cancel the action and get out of the Game Room, by calling the `CancelGameRoom` operation:\r\n```c#\r\npublic void CancelGameRoom()\r\n```\r\nThis will cancel the Game Room request and raise the `OnGameRoomDisconnect` event:\r\n```c#\r\npublic UnityEvent OnGameRoomDisconnect;\r\n```\r\nThe `OnGameRoomDisconnect` event is also triggered if you lose connection to Photon. You want to handle this event by going back to the Main screen ([`Stages.Master`](#stagesmaster)).\r\n\r\nWhen the second player connects, then the `OnPlayConnect` event is fired:\r\n```c#\r\npublic UnityEvent OnPlayConnect;\r\n```\r\nThe `OnPlayConnect` event is also fired if the room is already present and you are joining as the second player; in this case you will not have the time to cancel the game room request.\r\nYou want to handle the `OnPlayConnect` event by going to the Game Play scene.\r\n##### `Stages.Play`\r\nThis is the stage where the play happens, both players are joined to a Photon Game Room and exchanging commands and snapshots with the server to play the game. While in the Play stage, the `JUMPMultiplayer.IsPlayingGame` variable is set to true; note that this is a combination of both the `IsConnectedToGameRoom` and `IsRoomFull` properties.\r\n\r\nYou can cancel the game and get out of the room by calling `QuitPlay`:\r\n```c#\r\npublic void QuitPlay()\r\n```\r\nThis will exit the game room and trigger the `OnPlayDisconnected` event:\r\n```c#\r\npublic UnityEvent OnPlayDisconnected;\r\n```\r\nThe `OnPlayDisconnected` event is also fired if the other player leaves the room or if you lose connection to Photon.\r\nYou want to handle the `OnPlayDisconnected` event by telling the user the reason for the disconnection (using the `QuitGameReason` property) and then moving back to the Main screen ([`Stages.Master`](#stagesmaster)).\r\n\r\nWhen `JUMPMulyiplayer` enters in the Play stage, then the [`JUMPGameClient`](#jumpgameclient) is initialized. At this point the client connects to the [`JUMPGameServer`](#jumpgameserver) that in turn starts sending **Snapshots** to the client.\r\nThe `JUMPMultiplayer` will raise an `OnSnapshotReceived` event every time an snapshot is sent from the server to the client.\r\nFor more information on how to handle the Snapshots, see the [`JUMPGameServer`](#jumpgameserver) section.\r\n```c#\r\npublic JUMPSnapshotReceivedUnityEvent OnSnapshotReceived;\r\n```\r\n#### JUMPMultplayer Prefabs\r\nThe _/JUMP/Multiplayer_ folder contains five prefabs, one for each of the [Stages](#jumpmultiplayerstage).\r\nThe prefabs are:\r\n* JUMPMultiplayerConnection\r\n* JUMPMultiplayerMaster\r\n* JUMPMultiplayerMatchmakeLobby\r\n* JUMPMultiplayerGameRoom\r\n* JUMPMultiplayerPlay\r\n\r\nThe prefabs are simply a Game Object with a `JUMPMultiplayer` component set to the relative `Stage`. The idea is to place these in each of the five scenes that will compose the [UI Flow](#streamlined-ui-flow)\r\n\r\n#### JUMPGameClient\r\n`JUMPGameClient` uses the singleton pattern, to access it, use the `Singleton<JUMPGameClient>.Instance` property.\r\n\r\nYou use the `JUMPGameClient` to send commands to the server; to do so, just use the `SendCommandToServer` operation. To define your own commands, see [`JUMPCommand`](#jumpcommand).\r\n```c#\r\nSingleton<JUMPGameClient>.Instance.SendCommandToServer(new myCommand());\r\n```\r\n\r\nThe `ConnectToServer` operation and `OnSnapshotReceived` event are used internally by `JUMPMultiplayer`, you don't need to worry about them :)\r\n\r\n#### JUMPGameServer\r\nThe `JUMPGameServer` is managed by the `JUMPMultiplayer` class, you don't interact with it directly.\r\n`JUMPMultiplayer` uses a singleton `JUMPGameServer` insance to start the game, process client commands and send snapshots to the client.\r\n\r\nThe `JUMPGameServer` will send a numbe of snapshots to the client per second that can be customized setting the `JUMPOptions.SnapshotsPerSec` property, the default is 3 snapshots per second.\r\n\r\nThe `JUMPGameServer` is designed to interact with your custom Server Engine - just implement the [`IJUMPGameServerEngine`](#ijumpgameserverengine) interface and set the `GameServerEngineTypeName` property of a `JUMPMultiplayer` instance with Stage [`Stages.MatchmakeLobby`](#stagesmatchmakelobby) (or a *JUMPMultiplayerMatchmakeLobby* prefab).\r\n\r\n#### IJUMPGameServerEngine\r\nThe `IJUMPGameServerEngine` interface allows you to customize the Server Engine for your multiplayer game.\r\nAn instance of your Server Engine will be hosted by the [Master Client], all the communication between client and server is being taken care of by **JUMP**, you can focus on implementing your game logic.\r\n\r\nHere is the `IJUMPGameServerEngine` interface:\r\n```c#\r\npublic interface IJUMPGameServerEngine\r\n{\r\n    void StartGame(List<JUMPPlayer> Players);\r\n    void Tick(double ElapsedSeconds);\r\n    void ProcessCommand(JUMPCommand command);\r\n    JUMPCommand CommandFromEvent(byte eventCode, object content);\r\n    JUMPCommand_Snapshot TakeSnapshot(int ForPlayerID);\r\n}\r\n```\r\n\r\n###### `void StartGame(List<JUMPPlayer> Players)`\r\n**JUMP** will call StartGame when the `JUMPMultiplayer` is in the `MatchmakeLobby` stage and the player joins (or creates) a Room, right before calling `OnGameRoomConnect`.\r\nIn this operation, you want to initialize your game state, using the information on the `Players` list to save the list of players that are in the game.\r\n\r\nFor example, the [DiceRoller Custom Server](#diceroller-customs-erver) intializes its own GameState and saves the players using a custom DiceRollerPlayer class.\r\n\r\n###### `void Tick(double ElapsedSeconds)`\r\nOn the Master Server, `JUMPGameServer` calls `Tick` every frame update to make your game progress forward.\r\nDo anything time related in this operation; don't bother sending Snapshots, this is automated for you with the `TakeSnapshot` operation.\r\n\r\nFor example, the [DiceRoller Custom Server](#diceroller-customs-erver) counts down its 30 seconds timeout for the game, after that the game is over.\r\n\r\n###### `void ProcessCommand(JUMPCommand command)`\r\nThis is where you process your custom commands that the client sends.\r\n\r\nSee [JUMPCommand](#jumpcommand) for how to define your own commands and the [DiceRoller Custom Server](#diceroller-customs-erver) for an example of definition and use of a custom command.\r\n\r\n###### `JUMPCommand CommandFromEvent(byte eventCode, object content)`\r\n`JUMPGameServer` needs a way to find out if the Photon Event that it just received from the client comes from your Game Client and carries your custom command, in order to do so, you can implement the `CommandFromEvent` function, checking if the `eventCode` is one of your custom operations' one.\r\n\r\nSee, the [DiceRoller Sample](#diceroller-customs-erver) for an example on how to write this function.\r\n\r\n###### `JUMPCommand_Snapshot TakeSnapshot(int ForPlayerID)`\r\n`JUMPGameServer` will send Snapshots automatically to your clients; the `TakeSnapshot` function is where you can customize the Snapshot.\r\n\r\nSee, the [DiceRoller Custom Server](#diceroller-customs-erver) for an example on how to write this function.\r\n\r\n#### JUMPCommand\r\n`JUMPCommand` is a base class that allows **JUMP** to define commands and to send them and receive them using the Photon Events system. You can define your own custom commands with little coding.\r\n\r\n`JUMPCommand` uses the `CommandEventCode` property as Photon Event Code, this is a byte variable, in your game you can use any value from `0` to `189`.\r\nThe `CommandData` is an object array used to store and retrieve the data for your command, and that can be easily serialized with Photon messages. Only basic types are allowed as Command properties to store in `CommandData`, for more background information, see [Serialization In Photon](#https://doc.photonengine.com/en/realtime/current/reference/serialization-in-photon)\r\n\r\nCustom `JUMPCommand`s typically need two constructors, one used for reconstruction of the Command when received from Photon, and one used to initialize the CommandData before sending it to the server.\r\n\r\n`JUMPMultiplayer` uses `JUMPCommand_Connect` as a custom command used to connect the `GameClient`:\r\n```c#\r\npublic class JUMPCommand_Connect : JUMPCommand\r\n{\r\n    public const byte JUMPCommand_Connect_EventCode = 191;\r\n\r\n    public int PlayerID { get { return (int)CommandData[0]; } set { CommandData[0] = value; } }\r\n\r\n    public JUMPCommand_Connect(int playerID) : base(new object[1], JUMPCommand_Connect_EventCode)\r\n    {\r\n        PlayerID = playerID;\r\n    }\r\n\r\n    public JUMPCommand_Connect(object[] data) : base(data, JUMPCommand_Connect_EventCode)\r\n    {\r\n    }\r\n}\r\n```\r\n\r\nSee, the [DiceRoller Custom Server] for other examples on wiritng your own custom Commands.\r\n\r\n#### JUMPCommand_Snapshot\r\nThen the `JUMPGameServer` sends `JUMPCommand_Snapshot` periodically to the client.\r\n`JUMPCommand_Snapshot` is a `JUMPCommand` that has two property already set: the `JUMPSnapshot_EventCode` and the `ForPlayerID` property.\r\n\r\nYou can define your own Snapshot, by inheriting from the `JUMPCommand_Snapshot` class - \r\n\r\nSee, the [DiceRoller Custom Server] for other examples on wiritng your own custom Snapshots.\r\n\r\n#### JUMPPlayer\r\n`JUMPPlayer` is a simple class used to store basic information like `PlayerID` and `IsConnected`.\r\nYou can extend the `JUMPPlayer` with your own properties, like Score for example and keep them in your server state.\r\n\r\nSee, the [DiceRoller Custom Server] for an example on extendig the `JUMPPlayer` class.\r\n\r\n#### JUMPOptions\r\nYou can set a few options with the `JUMPOptions` class - here are the options with their defaults:\r\n\r\n```c#\r\npublic static class JUMPOptions\r\n{\r\n    public static string GameVersion = \"0.1\";\r\n    public static byte NumPlayers = 2;\r\n    public static int DisconnectTimeout = 10 * 1000;\r\n    public static int SnapshotsPerSec = 3;\r\n}\r\n```\r\n\r\nNote that `DisconnectTimeout` is set to 60 seconds if the build is in Debug mode.\r\n\r\n# DiceRoller Sample\r\nDiceRoller is a simple example of how to use **JUMP**.\r\nIt is made of five scenes, a custom Server Engine and a Game Manager for the play scene.\r\n\r\n#### Connection Scene\r\nThe Connection Scene has one instance of the **JUMPMultiplayerConnection** [prefab](#jumpmultiplayerprefabs) (as a reminder,  this is a behaviour that has a `JUMPMultplayer` component, with the `Stage` set as `Connection`).\r\n\r\nThe only event handled by the scene the `OnMasterDisconnect`, in which we load the Master Scene.\r\n\r\nThe Scene also uses the UI Prefab **JUMPStatusConnection** that displays the status of the connection with Photon.\r\n\r\n#### Master Scene\r\nThe Master Scene has has one instance of the **JUMPMultiplayerMaster** prefab.\r\n\r\nThe scene handles two events:\r\n* `OnMasterDisconnect` that goes back to the Connection Scene to try and reconnect once.\r\n* `OnMatchmakeLobbyConnect` that loads the Matchmake Lobby Scene\r\n\r\nThe scene uses a few more UI prefabs:\r\n* **JUMPStatusOnline** that displays if the client is online (connected with Photon) or offline\r\n* **JUMPStatusDefaultLobby** that displays the number of players connected to the Photon Lobby\r\n* **JUMPButtonMatchmake** a simple text button that is enabled when we are connected to the Photon Master Server; if the user clicks the button, then we invoke the `Matchmake` operation on the **JUMPMultiplayerMaster** prefab.\r\n\r\n#### Matchmake Lobby Scene\r\nThe Matchmake Lobby Scene has has one instance of the **JUMPMultiplayerMatchmakeLobby** prefab.\r\n\r\nThe scene handles two events:\r\n* `OnMatchmakeLobbyDisconnect` that goes back to the Master Scene.\r\n* `OnGameRoomConnect` that loads the Game Room Scene\r\n\r\nIt also sets the `GameServerEngineTypeName` variable to `\"DiceRollerSample.DiceRollerEngine\"` to create a custom server engine - for details see the [DiceRoller Custom Server].\r\n\r\nThe scene uses a few more UI prefabs:\r\n* **JUMPButtonCancelMatchmake** which is enabled during this phase of the UI Flow. If the user clicks the button, then we invoke the `CancelMatchmake` operation on the **JUMPMultiplayerMatchmakeLobby** prefab.\r\n\r\n#### Game Room Scene\r\nThe Game Room Scene has one instance of the **JUMPMultiplayerGameRoom** prefab.\r\n\r\nThe scene handles two events:\r\n* `OnGameRoomDisconnect` that goes back to the Master Scene.\r\n* `OnPlayConnect` that loads the Play Scene\r\n\r\nThe scene uses a few more UI prefabs:\r\n* **JUMPStatusGameRoom** that displays how many players are in the room.\r\n* **JUMPButtonCancelGameRoom** which is enabled during this phase of the UI Flow. If the user clicks the button, then we invoke the `CancelGameRoom` operation on the **JUMPMultiplayerGameRoom** prefab.\r\n\r\n#### Play Scene\r\nThe Game Room Scene has one instance of the **JUMPMultiplayerPlay** prefab.\r\n\r\nThe scene handles two events:\r\n* `OnPlayDisconnect` that goes back to the Master Scene.\r\n* `OnSnapshotReceived` that handles the Snapshots form the server via the DiceRollerGameManager - see [DiceRoller Custom Server] for details\r\n\r\nThe scene uses a few more UI prefabs:\r\n* **JUMPButtonQuitPlay** hich is enabled during this phase of the UI Flow. If the user clicks the button, then we invoke the `QuitPlay` operation on the **JUMPMultiplayerPlay** prefab.\r\n\r\n### DiceRoller Custom Server\r\nDiceRoller is a simple game, two players roll a dice and try to score the most points in 30 seconds.\r\nTo function, DiceRoller needs the Scenes and two additional components:\r\n* Gustom Server\r\n* Game Manager script for the Play Scene\r\n\r\n> Note: for simplicity of implementation, the action of rolling a dice is non-authoritative: the clients decide the outcome of rolling the dice autonomously; this helps keeping the DiceRoller sample code very straightforward and simple to understand. In your game you might want to have the server take the decisions on the outcome of player actions like this.\r\n\r\n#### Custom Server\r\nTo create a custom server, DiceRoller implements the [`IJUMPGameServerEngine`](#ijumpgameserverengine) interface:\r\n\r\n##### DiceRollerCommand_RollDice\r\nDiceRoller defines a custom command for rolling the dice, this inherits from `JUMPCommand` and extends it:\r\n\r\n```c#\r\npublic class DiceRollerCommand_RollDice : JUMPCommand\r\n{\r\n    public const byte RollDice_EventCode = 100;\r\n\r\n    public int PlayerID { get { return (int)CommandData[0]; } set { CommandData[0] = value; } }\r\n    public int RolledDiceValue { get { return (int)CommandData[1]; } set { CommandData[1] = value; } }\r\n\r\n    // Create a command to send with this initializer\r\n    public DiceRollerCommand_RollDice(int playerID, int rolledDiceValue) : base(new object[2], RollDice_EventCode)\r\n    {\r\n        PlayerID = playerID;\r\n        RolledDiceValue = rolledDiceValue;\r\n    }\r\n\r\n    // Create a command when receiving it from Photon\r\n    public DiceRollerCommand_RollDice(object[] data) : base(data, RollDice_EventCode)\r\n    {\r\n    }\r\n}\r\n```\r\n\r\nNote the definition of the event code: `RollDice_EventCode`, the use of the standard `PlayerID` property as the first value in the CommanData array and the definition of two constructors: `DiceRollerCommand_RollDice(object[] data)` used to create the command from the Photon message and `DiceRollerCommand_RollDice(int playerID, int rolledDiceValue)` used to send the message.\r\n\r\n##### DiceRollerPlayer\r\nDiceRoller defines a custom Player to store the game state in [`DiceRollerGameState`](#dicerollergamestate).\r\n\r\n```c#\r\npublic class DiceRollerPlayer : JUMPPlayer\r\n{\r\n    public int Score = 0;\r\n}\r\n```\r\n\r\nNote the inheritance from `JUMPPlayer` and the addition of the only property that matters in this case, the Score.\r\n\r\n##### DiceRollerGameState\r\nDiceRoller custom server defines theits own game state of course - this contains a list of `DiceRollerPlayers`, the time remaining in the game, the stage of the game (can be waiting for the players, playing or complete) and the time remaining when the game is being played:\r\n\r\n```c#\r\npublic enum DiceRollerGameStages\r\n{\r\n    WaitingForPlayers,\r\n    Playing,\r\n    Complete\r\n}\r\n\r\npublic class DiceRollerGameState\r\n{\r\n    public Dictionary<int, DiceRollerPlayer> Players = new Dictionary<int, DiceRollerPlayer>();\r\n    public float SecondsRemaining;\r\n    public DiceRollerGameStages Stage;\r\n    public int WinnerPlayerID;\r\n}\r\n```\r\n\r\n##### DiceRoller_Snapshot\r\nTo communicate the state of the game with the clients, the DiceRoller custom server must define a Snapshot.\r\nThe `DiceRoller_Snapshot` class inherits from `JUMPCommand_Snapshot` and so can make use of the array of data `CommandData`, the `JUMPSnapshot_EventCode` and the `ForPlayerID` properties already defined in the base class.\r\n\r\nAll it needs to do is to define two constructors and use the `CommandData` array to store the Snapshot data.\r\n\r\nNote that a Snapshot is different from the GameState because it is aimed to only one of the two players: players should not see each other's data (for example if they have playing cards). \r\n\r\n```c#\r\npublic class DiceRoller_Snapshot : JUMPCommand_Snapshot\r\n{\r\n    // ForPlayerID is at CommandData[0]\r\n    public int MyScore { get { return (int)CommandData[1]; } set { CommandData[1] = value; } }\r\n    public int OpponentScore { get { return (int)CommandData[2]; } set { CommandData[2] = value; } }\r\n    public float SecondsRemaining { get { return (float)CommandData[3]; } set { CommandData[3] = value; } }\r\n    public DiceRollerGameStages Stage { get { return (DiceRollerGameStages)CommandData[4]; } set { CommandData[4] = value; } }\r\n    public int WinnerPlayerID { get { return (int)CommandData[5]; } set { CommandData[5] = value; } }\r\n\r\n    // Create a command to send with this initializer\r\n    public DiceRoller_Snapshot() : base(new object[6])\r\n    {\r\n    }\r\n\r\n    // Create a command when receiving it from Photon\r\n    public DiceRoller_Snapshot(object[] data) : base(data)\r\n    {\r\n    }\r\n}\r\n```\r\n\r\nNote how the `DiceRoller_Snapshot()` constructor creates a new array with 6 elements: one for the `ForPlayerID` property used by the `JUMPCommand_Snapshot` base class and five for the custom properties.\r\nAlso note how the properties are stored from the second element in the array on, because `ForPlayerID` is stored at element 0.\r\n\r\n##### DiceRollerEngine\r\nThe `DiceRollerEngine` class implements the `IJUMPGameServerEngine` interface.\r\n\r\nIt uses an internal variable to hold the state:\r\n\r\n```c#\r\nprivate DiceRollerGameState GameState;\r\n```\r\n\r\nThe constructor simply initializes the state in the waiting for players mode:\r\n\r\n```c#\r\npublic DiceRollerEngine()\r\n{\r\n    GameState = new DiceRollerGameState();\r\n    GameState.Stage = DiceRollerGameStages.WaitingForPlayers;\r\n}\r\n```\r\n\r\nThe `CommandFromEvent` function handles the RollDice custom command:\r\n\r\n```c#\r\npublic JUMPCommand CommandFromEvent(byte eventCode, object content)\r\n{\r\n    if (eventCode == DiceRollerCommand_RollDice.RollDice_EventCode)\r\n    {\r\n        return new DiceRollerCommand_RollDice((object[]) content);\r\n    }\r\n    return null;\r\n}\r\n```\r\n\r\nThe `StartGame` operation gets the information about the players and sets the state of the game:\r\n\r\n```c#\r\npublic void StartGame(List<JUMPPlayer> Players)\r\n{\r\n    GameState = new DiceRollerGameState();\r\n    GameState.SecondsRemaining = 30;\r\n    GameState.Stage = DiceRollerGameStages.Playing;\r\n\r\n    foreach (var pl in Players)\r\n    {\r\n        DiceRollerPlayer player = new DiceRollerPlayer();\r\n        player.PlayerID = pl.PlayerID;\r\n        player.IsConnected = pl.IsConnected;\r\n        player.Score = 0;\r\n\r\n        GameState.Players.Add(player.PlayerID, player);\r\n    }\r\n}\r\n```\r\n\r\nThe `ProcessCommand` handles the server state when a client sends a RollDice command (the connect commands are manager automatically by the `JUMPGameServer` class).\r\n\r\n```c#\r\npublic void ProcessCommand(JUMPCommand command)\r\n{\r\n    if (command.CommandEventCode == DiceRollerCommand_RollDice.RollDice_EventCode)\r\n    {\r\n        DiceRollerCommand_RollDice rollDiceCommand = command as DiceRollerCommand_RollDice;\r\n\r\n        DiceRollerPlayer player;\r\n        if (GameState.Stage == DiceRollerGameStages.Playing)\r\n        {\r\n            if (GameState.Players.TryGetValue(rollDiceCommand.PlayerID, out player))\r\n            {\r\n                player.Score += rollDiceCommand.RolledDiceValue;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe `Tick` operation handles the game clock, when the clock expires, the game state is changed to Coplete and a winner is determined.\r\n\r\n```c#\r\npublic void Tick(double ElapsedSeconds)\r\n{\r\n    if (GameState.Stage == DiceRollerGameStages.Playing)\r\n    {\r\n        GameState.SecondsRemaining -= (float) ElapsedSeconds;\r\n        if (GameState.SecondsRemaining <= 0)\r\n        {\r\n            int maxscore = 0;\r\n            int winner = -1;\r\n            foreach (var item in GameState.Players)\r\n            {\r\n                if (item.Value.Score > maxscore)\r\n                {\r\n                    maxscore = item.Value.Score;\r\n                    winner = item.Key; \r\n                }\r\n            }\r\n            GameState.Stage = DiceRollerGameStages.Complete;\r\n            GameState.WinnerPlayerID = winner;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe `TakeSnapshot` operation is called by `JUMPGameServer` to send the snapshot to a player, so the snapshot is created for that specific player:\r\n\r\n```c#\r\npublic JUMPCommand_Snapshot TakeSnapshot(int ForPlayerID)\r\n{\r\n    DiceRoller_Snapshot snap = new DiceRoller_Snapshot();\r\n    snap.ForPlayerID = ForPlayerID;\r\n    snap.MyScore = 0;\r\n    snap.OpponentScore = 0;\r\n    foreach (var item in GameState.Players)\r\n    {\r\n        if (item.Value.PlayerID == ForPlayerID)\r\n        {\r\n            snap.MyScore = item.Value.Score;\r\n        }\r\n        else\r\n        {\r\n            snap.OpponentScore = item.Value.Score;\r\n        }\r\n    }\r\n    snap.SecondsRemaining = GameState.SecondsRemaining;\r\n    snap.Stage = GameState.Stage;\r\n    snap.WinnerPlayerID = GameState.WinnerPlayerID;\r\n\r\n    return (JUMPCommand_Snapshot) snap;\r\n}\r\n```\r\n\r\n#### Game Manager\r\nThe final piece of **DiceRoller** is the `DiceRollerGameManager`, this is the Controller part in the MVC pattern: displaying the information in the user interface (View) and working with the `Snapshot` (Model) received by the `JUMPMultiplayer` class (see [Play Scene](#play-scene)).\r\n\r\n'DiceRollerGameManager' is a 'MonoBehaviour' and uses multiple `Text` and `Button` controls to display and control the game:\r\n\r\n```c#\r\npublic Text MyScore;\r\npublic Text TheirScore;\r\npublic Text GameStatus;\r\npublic Text TimeLeft;\r\npublic Text Result;\r\npublic Button RollDice;\r\n```\r\n\r\nWhen a snapshot is received, the controls are updated:\r\n\r\n```c#\r\nDiceRollerGameStages UIStage = DiceRollerGameStages.WaitingForPlayers;\r\n\r\npublic void OnSnapshotReceived(JUMPCommand_Snapshot data)\r\n{\r\n    DiceRoller_Snapshot snap = new DiceRoller_Snapshot(data.CommandData);\r\n    GameStatus.text = snap.Stage.ToString();\r\n    MyScore.text = snap.MyScore.ToString();\r\n    TheirScore.text = snap.OpponentScore.ToString();\r\n    TimeLeft.text = snap.SecondsRemaining.ToString(\"0.\");\r\n    UIStage = snap.Stage;\r\n    if (UIStage == DiceRollerGameStages.Complete)\r\n    {\r\n        Result.text = (snap.MyScore > snap.OpponentScore) ? \"You Won :)\" : ((snap.MyScore == snap.OpponentScore) ? \"Tied!\" : \"You Lost :(\");\r\n    }\r\n}\r\n```\r\n\r\nThe user can roll a dice, this operation will send the custom command to the server using the `JUMPGameClient` singleton:\r\n\r\n```c#\r\npublic void RollADice()\r\n{\r\n    int score = UnityEngine.Random.Range(1, 6);\r\n    if (RollDice != null)\r\n    {\r\n        RollDice.GetComponent<Text>().text = \"Rolled a \" + score + \" \\nroll again..\"; \r\n    }\r\n    Singleton<JUMPGameClient>.Instance.SendCommandToServer(new DiceRollerCommand_RollDice(PhotonNetwork.player.ID, score));\r\n}\r\n```\r\n\r\nFinally, the Unity `Start` function is used to initialize the random seed and in the `Update` function we enable the RollDice button only if we are playing:\r\n\r\n```c#\r\n// Use this for initialization\r\nvoid Start () {\r\n    UnityEngine.Random.seed = System.DateTime.Now.Millisecond;\r\n}\r\n\r\n// Update is called once per frame\r\nvoid Update () {\r\n    RollDice.interactable = (UIStage == DiceRollerGameStages.Playing);\r\n}\r\n```\r\n\r\n# Testing JUMP\r\nGiven the fact that Unity does not allow the same project to be opened in two different instances of the Unity Editor and that it can only run one scene at a time, it is very hard to create test automation and to test **JUMP**.\r\nWe have done manual testing, but finding a way to automate some of this test would be ideal.\r\nWe thought about mocking, but then it would require to mock the behaviour of Photon, making assumptions that might not be matched in the real case and invalidating the tests.\r\n\r\nSo we worked with manual tests so far, here are the test cases we tried:\r\n\r\n##### Start the game\r\n* Start a Game from the Connection Scene -> the Game should end in the Master  scene with Offline mode on.\r\n* Start a Game from any other scene -> the Game should go back to the connection Scene and then end in the Master scene with Offline mode on.\r\n* Start a Game with no connection from any Scene -> the Game should end in the Master scene with Offline mode on.\r\n\r\n##### Disconnect from the game\r\n* When on any scene, disconnect the network -> the Game should go back to the connection Scene and then end in the Master  scene with Offline mode on.  \r\n\r\n##### Matchmake\r\n* When on the Master scene, press Matchmake -> the Game should go to the Matchmake screen then the Game should go to the Game Room waiting scene; if there is at least another player in matchmaking, then the game should go to the Play scene.\r\n* When on the Matchmake scene if the user press Cancel Matchmaking -> the Game should go back to the main scene; if there is at least another player in matchmaking, then the game should continue on to the Play scene.\r\n\r\n##### Game Room waiting\r\n* When on the Game Room waiting scene, if the user press Cancel -> the game should go back to the Master scene\r\n\r\n##### Play\r\n* When on the Play scene, if the user press Quit -> the game shouls go back to the Master scene\r\n\r\n\r\n# Features to add\r\n* Unit test, or at least automation test (with Unity allowing a single window and a single instance this is hard)\r\n* Support for bots when there are not enough players online (users in a room by himself for too long)\r\n* Improved reliability and speed with delta compression of Snapshots and list of not-acknowledged Commands.\r\n* Matchmaking not random but with customizable criteria (SQLLobbies)\r\n* Source Code comments on public variables and methods?\r\n\r\n\r\n---\r\n\r\n# License\r\n\r\nUnless stated otherwise all works are Copyright &copy; 2016 [Juiced Team LLC.](http://www.juicedteam.com)\r\n\r\nAnd licensed under the [MIT License](https://raw.githubusercontent.com/MaurGi/JUMP/master/LICENSE.txt)\r\n\r\n### Donate\r\nIf you want to donate, you can simply [purchase the JUMP package in the Unity Asset Store][JUMPAsset].\r\n\r\n### Contribute\r\nWe are not ready to accept pull requests at the time, we are considering that for the future.\r\nIf you are interested in contributing, file a bug and we will consider your request.\r\nAll contributions will be voluntary and will grant no rights, compensation or license, you will retain the rights to reuse your code.\r\n\r\n### Attribution\r\nPhoton, Photon Engine, PUN: &copy;2016 [Exit Games](https://www.photonengine.com)&reg; \r\n\r\nUnity 3D, Unity Engine: &copy;2016 [Unity Technologies](http://unity.com)\r\n\r\n[Unity 3D]: <http://unity3d.com/unity>\r\n[Photon Unity Networking]: <http://www.photonengine.com/PUN>\r\n[Photon Cloud]: <http://www.photonengine.com/en-US/Realtime>\r\n[Master Client]: <http://doc.photonengine.com/en/pun/current/tutorials/tutorial-marco-polo>\r\n[Photon Lobby]: <http://doc.photonengine.com/en/realtime/current/reference/matchmaking-and-lobby>\r\n[Gambetta]:<http://www.gabrielgambetta.com/fpm1.html>\r\n[TODOPicture]:<https://upload.wikimedia.org/wikipedia/commons/2/21/OpenGL_Tutorial_TODO.png>\r\n[CallOfDuty]:<http://schedule.gdconf.com/session/fighting-latency-on-call-of-duty-black-ops-iii>\r\n[JUMPAsset]:<http://u3d.as/sQw>\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}